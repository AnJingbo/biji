

## 一、操作系统概述
### 1.1 操作系统的概念、功能和目标
#### 计算机系统的概念
**操作系统**（Operating System，OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其它软件方便的接口和环境，它是计算机系统是最基本的**系统软件**。
![图示](https://img-blog.csdnimg.cn/67df389ded894245bf8abb0436170c15.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 操作系统的功能和目标-作为系统资源的管理者（这些资源包括硬件、软件、文件等）
补充：进程是一个程序的执行过程。执行前需要将该程序放到内存中，才能被CPU处理。
![图示](https://img-blog.csdnimg.cn/66bf717084cf4640b741fbf6a154d39c.png)
#### 操作系统的功能和目标-作为用户和计算机硬件之间的接口
命令接口：允许用户直接使用。
程序接口：允许用户通过程序间接使用。  
GUI：现代操作系统中最流行的图形用户接口。用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。
![图示](https://img-blog.csdnimg.cn/1a7eadc0c1714c2ea45acf1fcb154333.png)
![图示](https://img-blog.csdnimg.cn/2803c5b5b3a1454192c2b345b2afd397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 操作系统的功能和目标-作为最接近硬件的层次
* 需要提供的功能和目标：实现对硬件机器的扩展。
* 没有任何软件支持的计算机称为**裸机**。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强，使用更方便的机器。
* 通常把覆盖了软件的机器称为**扩充机器**，又称之为**虚拟机**。
* 类比：硬件可以类比为锤子、锯子、木头等，操作系统可以类比为优秀的工匠。操作系统对硬件机器的扩展：通过优秀的工匠，这些简单的原料可以组织成房子、帆船等。普通的用户可以直接使用工匠提供的房子、帆船等，而不用关心这些东西在底层是怎么组织起来工作的。
### 1.2 操作系统的特征
![图示](https://img-blog.csdnimg.cn/3ccb0e7bad9e4caf83e40ff49bac3b8a.png)
#### 并发
* **并发**：指两个或多个事件在同一时间间隔内发生，这些事件**宏观上是同时发生**的，但**微观上是交替发生**的。
* **并行**：指两个或多个事件在同一时刻同时发生。
* **操作系统的并发性**指计算机系统中同时存在着多个运行着的程序。
* 一个单核处理机（CPU）同一时刻只能执行一个程序，因此操作系统会负责协调多个程序交替执行（这些程序微观上是交替执行的，但宏观上看起来就像在同时执行）
* 事实上，操作系统就是伴随着“多道程序技术”而出现的。因此，**操作系统和程序并发是一起诞生的。**
* 当今的计算机，一般都是多核 CPU。
#### 共享
* 共享，即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。
![图示](https://img-blog.csdnimg.cn/65cfff945cd442b09fbad2802ad7f8f5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 并发和共享的关系
* **并发性**：指计算机系统中同时存在着多个运行着的程序。
* **共享性**：指系统中的资源可供内存中多个并发执行的进程共同使用。
* 如果失去并发性，那么系统中只有一个程序正在运行，则共享性失去存在的意义；如果失去共享性，则不同的程序不能同时访问硬盘资源，也就无法并发。
#### 虚拟
* **虚拟**是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的，而逻辑上的对应物是用户感受到的。
* 一个程序**需要放入内存**并把它**分配给 CPU** 才能执行。

![图示](https://img-blog.csdnimg.cn/6b550a78ff0b48e790dce416a88320e3.png)
* 显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，**没有并发性，就谈不上虚拟性。**
#### 异步
* **异步**是指，在多道程序的环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。
* 如果失去了并发性，则系统只能串行地处理各个进程，每个进程的执行会一贯到底。因此**只有系统拥有并发性，才有可能导致异步性。**
#### 小结
* 没有并发和共享，就谈不上虚拟和异步，因此并发和共享是操作系统中的两个最基本的特征。
### 1.3 操作系统的发展与分类
![图示](https://img-blog.csdnimg.cn/3c9adbafca834911b3d50c690a22ba2f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 手工操作阶段
![图示](https://img-blog.csdnimg.cn/c8031946673d4a9a92c8973e4e3907aa.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低。
#### 批处理阶段-单道批处理系统
* 引入**脱机输入/输出技术**（用磁带完成），此使用**监督程序（操作系统的雏形）** 负责控制作业的输入、输出。
![图示](https://img-blog.csdnimg.cn/a179e0eeca464120a22ddca292ef9370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。
* 主要缺点：**内存中仅能有一道程序运行**，只有该程序运行结束之后才能调入下一道程序。**CPU 有大量的时间是在空闲等待 I/O 完成**。资源利用率依然很低。
#### 批处理阶段-多道批处理系统
![图示](https://img-blog.csdnimg.cn/06376b6b84034c4680b21cdbc2d83221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 主要优点：多道程序**并发**执行，**共享**计算机资源。**资源利用率大幅提升**，CPU 和其它资源保持“忙碌”状态，系统吞吐量增大。
* 主要缺点：用户响应时间长，**没有人机交互功能**（用户提交自己的作业之后只能等待计算机处理完成，中间不能控制自己的作业执行）
#### 分时操作系统
* 分时操作系统：计算机以**时间片**为单位**轮流为各个用户/作业服务**，各个用户可通过终端与计算机进行交互。
![图示](https://img-blog.csdnimg.cn/1f6ecb8afc66446aa1d4c7d0893458bb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 主要优点：用户请求可以被即时响应，**解决了人机交互问题**。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。
* 主要缺点：**不能优先处理一些紧急任务**。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。
#### 实时操作系统
![图示](https://img-blog.csdnimg.cn/55d9691018044e0db610e717484e5a68.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 主要优点：能够优先响应一些紧急任务，某些紧急任务不需要时间片排队。
* 在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且**要在严格的时限内处理完事件**。实时操作系统的**主要特点是及时性和可靠性**。
#### 其他几种操作系统
![图示](https://img-blog.csdnimg.cn/ea5b031db31243cbacf6d5c3957fb0ca.png)
#### 小结
![图示](https://img-blog.csdnimg.cn/ae44ad1e3ab645cdb2291ce61ad269c1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 1.4 操作系统的运行机制与体系结构
![图示](https://img-blog.csdnimg.cn/be1852061862443390ffdf757d13fb45.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 什么是指令
* 简单来说，**指令就是处理器（CPU）能识别、执行的最基本命令。** 一条高级语言代码翻译过来可能对应多条指令。
#### 两种指令、两种处理器状态、两种程序
![图示](https://img-blog.csdnimg.cn/9b782041a5094a2da5924e1ba9bc2133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* `用户态 -> 核心态`是通过`中断`实现的，并且`中断是唯一途径`。
* **特权指令、内核程序**只能在**核心态**下运行。
#### 操作系统的内核
* **内核**是计算机配置的底层**软件**，是操作系统最基本、最核心的部分。
* 实现操作系统内核功能的那些程序就是**内核程序**。
![图示](https://img-blog.csdnimg.cn/42755ebce4904f7ab120a17a43001157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/67fbb759989742a3bd3228e6cad0aaac.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 操作系统的体系结构
![图示](https://img-blog.csdnimg.cn/930a46e5bc444225a9909d9b5971ae37.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 1.5 中断和异常
#### 中断机制的诞生
* 在早期计算机中，程序只能串行地执行。一个程序进入内存中，接下来程序开始运行，运行结束后需等待 I/O 设备输出结束，程序才可从内存中移出，接下来再移入第二道程序 ......
* 为解决上述问题，人们发明了操作系统（作为计算机的管理者），引入中断机制，实现了多道程序并发执行。
* **本质：发生中断就意味着需要操作系统介入，开展管理工作。**
#### 中断的概念和作用
![图示](https://img-blog.csdnimg.cn/c7c8b0cc69a441a9b7f87a4e9c7b2682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 中断的分类
![图示](https://img-blog.csdnimg.cn/8206abad9d2247cc8c100e4c141abc36.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/39c133223d864ae09d59a9cdf9b3e3fe.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 外中断的处理过程
![图示](https://img-blog.csdnimg.cn/625c3d0160cc43988f3de3a39978f18b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 1.6 系统调用
#### 什么是系统调用，有何作用？
* 回顾：操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组**系统调用**组成。
![图示](https://img-blog.csdnimg.cn/41662bffe5604d219440aeebf519162f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* “系统调用”是操作系统提供给应用程序（编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，**应用程序可以发出系统调用请求来获得操作系统的服务。**
* 操作系统为什么要提供系统调用功能？
![图示](https://img-blog.csdnimg.cn/d8828ebf79fb4bd38419703f94531856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 应用程序通过**系统调用**请求操作系统的服务。系统中的各种共享资源由操作系统统一管理，因此在用户程序中，凡是与资源有关的操作（如存储分配、I/O 操作、文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样**可以保证系统的稳定性和安全性**，防止用户进行非法操作。
![图示](https://img-blog.csdnimg.cn/9040f1296ef74d759fd7ee3056fcb971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* **系统调用会使 CPU 从用户态进入核心态。**
#### 系统调用和库函数的区别
![图示](https://img-blog.csdnimg.cn/6a29b937119149f4a941396ef4cab00b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 系统调用背后的过程
![tushi ](https://img-blog.csdnimg.cn/f14e2e07d03942748b01e0d068acac0e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* `传递系统调用参数 -> 执行陷入指令（用户态） -> 执行系统调用相应服务程序（核心态） -> 返回用户程序`
* 注意：
（1）**陷入指令**是在**用户态**执行的，执行陷入指令之后会立即引发一个**内中断**，从而 CPU **进入核心态**。
（2）**发出系统调用请求**是在**用户态**，而**对系统调用的相应处理**在**核心态**下进行。
（3）**陷入指令**是**唯一**一个**只能在用户态执行，而不可在核心态执行的指令。**
## 二、进程与线程
### 2.1 进程基础知识
#### 进程的定义
* **程序**：就是一个指令序列。
* **进程实体（进程映像）由 PCB、程序段、数据段三部分组成。** 一般情况下，我们把进程实体简称为进程。例如，所谓创建进程，实质上是创建进程实体中的 PCB；而撤销进程，实际上是撤销进程实体中的 PCB。注意：**PCB 是进程存在的唯一标志。**
（1）系统为每个运行的程序配置了一个数据结构，称为**进程控制块（PCB）**，用来描述进程的各种信息（如程序代码存放位置）
（2）程序的代码存放在程序段内，程序运行过程处理的数据放在数据段内（如变量）
* 从不同的角度，进程可以有不同的定义：
（1）**进程是程序的一次执行过程（强调动态性）**
（2）进程是一个程序及其数据在处理机上顺序执行时所**发生的活动。**
（3）进程是具有独立功能的程序在数据集合上**运行的过程**，它是系统进行资源分配和调度的一个独立单位。
* 引入进程实体的概念后，可把进程定义为：**进程**是进程实体的**运行过程**，是系统进行**资源分配和调度**的一个独立单位。
* 注意：严格来说，进程实体和进程并不一样。**进程实体是静态的，进程则是动态的。**
#### 进程的组成（一个进程内部）
* 进程（进程实体）由**程序段、数据段、PCB** 三部分组成。
（1）程序段：存放要执行的程序代码。
（2）数据段：程序运行时使用、产生的运算数据，如全局变量、局部变量等就存放在数据段内。
（3）PCB：**操作系统通过 PCB 来管理进程**，因此 PCB 中应该包含操作系统对其进行管理所需的各种信息。

![图示](https://img-blog.csdnimg.cn/56d2319699e04ebdb7cc9b926065a33b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/0b698bfccb5e43b5935566baa462356d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 进程的组织（多个进程之间）
* 在一个系统中，通常有成千上百个 PCB，为了能对它们进行有效的管理，应当用适当的方式将这些 PCB 组织起来。
![图示](https://img-blog.csdnimg.cn/b67dc232a4fa4de68b0829d05f260234.png)
#### 进程的组织-链接方式
![图示](https://img-blog.csdnimg.cn/81597c1dda314a4eb07242c1762c1cb4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 进程的组织-索引方式
![图示](https://img-blog.csdnimg.cn/4bc1edfe7ed94a9ebbf98e00999f9cf5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 进程的特征
![图示](https://img-blog.csdnimg.cn/1b6f90fb0f914806ae68f06dc5ea8638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 2.2 进程的状态与转换
#### 进程的状态 - 三种基本状态
* 进程是程序的一次执行。在这个执行过程中，有时进程正在被 CPU 处理，有时又需要等待 CPU 服务，可见进程的状态是会变化的。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态。
![图示](https://img-blog.csdnimg.cn/416783cc083c4bc39b038f12aa932c5c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 进程的状态 - 另外两种状态
![图示](https://img-blog.csdnimg.cn/39dc4dcc97e64e73a7fae4ae0bf04ce2.png)
#### 进程状态的转化
![图示](https://img-blog.csdnimg.cn/bd384c3f3cb248878e4c4c47ab6b51f5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 2.3 进程控制
#### 什么是进程控制
* 进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。
* 简而言之，**进程控制就是要实现进程状态转换**。
#### 如何实现进程控制
* 进程的组织：
![图示](https://img-blog.csdnimg.cn/31d736fd3b92440f879770a91f291e7e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/2be5e52bce6940c3b2453ac155f2374c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 执行关中断指令后，会忽略外部中断信号；执行开中断指令后，接收到外部中断信号后才会进入相应的中断处理程序进行处理。**因此开/关中断指令的权限很大，是只允许在核心态下执行的特权指令。**
#### 进程控制相关的原语
![图示](https://img-blog.csdnimg.cn/bda38a9318d64f6c994338e692186472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
注：因何事阻塞就应由何事唤醒，因此**阻塞原语和唤醒原语必须成对使用**。
### 2.4 进程通信
* 进程通信是指进程之间的信息交换。
* 进程是分配系统资源的单位，因此**各进程**拥有的**内存地址空间必须相互独立。**
* 为了保证安全，**一个进程不能直接访问另一个进程的地址空间。**
* 但是进程间的信息交换是必须实现的，因此**操作系统提供了一些方法以保证进程间的安全通信。**
![图示](https://img-blog.csdnimg.cn/9454f7c62aa04df7b631dc6f181eb7e0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 进程通信-共享存储
* 操作系统为两个进程分配共享空间，两个进程的通信就能通过共享空间来完成。
![图示](https://img-blog.csdnimg.cn/a96884622e8444819e3aab3aad4bcc33.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 两个进程对共享空间的**访问**必须是**互斥**的（互斥访问通过操作系统提供的工具实现）
* 操作系统只负责提供共享空间和同步互斥工具（如 P、V 操作）
#### 进程通信-管道通信
![图示](https://img-blog.csdnimg.cn/c3980f7ddcfc4d39aa589990b8e5e7a9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 进程通信-消息传递
* 进程间的数据交换以**格式化的消息（Message）**为单位。进程通过操作系统提供的**“发送消息/接收消息”两个原语进行数据交换。**
![图示](https://img-blog.csdnimg.cn/0b70c76019ad47afa8ce0dc9e546b47a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bSU5rOi5rOi5ZWK,size_20,color_FFFFFF,t_70,g_se,x_16)
### 2.5 线程
#### 什么是线程，为什么要引入线程？
* 进程是程序的一次执行，但这些功能显然不可能是由一个程序顺序执行就能实现的。有的进程可能需要“同时”做很多事，例如 QQ 可以视频聊天，也可以传送文件。但传统的进程只能串行地执行一系列程序。为此，引入了线程来增加并发度。
![图示](https://img-blog.csdnimg.cn/58186c3147bd4023810e7761a66ed4f8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 可以把线程理解为“轻量级进程”。
* **线程**是一个**基本的 CPU 执行单元**。也是**程序执行流的最小单位。**
* 引入线程后，不仅是进程之间可以并发，进程内的**各个线程之间**也可以**并发**，从而进一步**提升了系统的并发度**，使得一个进程内也可以并发处理各种任务（如：QQ 视频、文字聊天、传文件）
* 引入线程后，**进程**只作为**除 CPU 之外的系统资源的分配单元**（如打印机、内存地址空间等都是分配给进程的）

#### 引入线程机制后，有什么变化
![图示](https://img-blog.csdnimg.cn/08b0502371184a2ba01f6adc8e2a1ec3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 线程的属性
![图示](https://img-blog.csdnimg.cn/2193b848e43b44458bf9793018784a73.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 线程的实现方式
* 线程的**实现方式**有两种：**用户级线程、内核级线程**。
* 用户级线程：
![图示](https://img-blog.csdnimg.cn/603c46dcbdf347c79cd8b2fc183683a1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 内核级线程：
![图示](https://img-blog.csdnimg.cn/59e2c504eee94f09b9d815c3d33d6708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式，将 n 个用户级线程映射到 m 个内核级线程上（n >= m）
![图示](https://img-blog.csdnimg.cn/94c50e0c518d42cbb9971d64584fd099.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* **注：操作系统只看得见内核级线程，因此只有内核级线程才是 CPU 分配的单位。**
#### 多线程模型
* 在同时支持用户级线程和内核级线程的系统中，由**几个用户级线程映射到几个内核级线程**的问题引出了多线程模型的问题。
* **多对一**模型：多个用户级线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。
![图示](https://img-blog.csdnimg.cn/2b214feb5db045468b5dcb10c5e546ea.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* **一对一**模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。
![图示](https://img-blog.csdnimg.cn/9bcfe5544d644f2ba922dbc0bb1b1c5e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* **多对多**模型：n 个用户级线程映射到 m 个内核级线程（**n >= m**）。每个用户进程对应 m 个内核级线程。
![图示](https://img-blog.csdnimg.cn/28c731ab43434cd6bd825df973589b8a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 2.6 处理机调度
#### 调度的基本概念
![图示](https://img-blog.csdnimg.cn/57be74f54f61404289c3a034383edc2a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 调度的三个层次
![图示](https://img-blog.csdnimg.cn/bf9a69f116664e238908bac0fcdd7402.png)
#### 高级调度
* 由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。
* **高级（作业）调度**：按一定的原则从外存上处于后备队列的作业中挑出一个（或多个）作业，给它们分配内存等必要的资源，并**建立相应的进程（建立 PCB）**，以使它（们）**获取竞争处理机的权利。**
* 高级调度是外存（辅存）与内存之间的调度。每个作业只调入一次，调出一次。**作业调入是会建立对应的 PCB，作业调出时才撤销 PCB**。高级调度只要是指调入的问题。因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束后才调出。
#### 中级调度
* **中级（内存）调度**：决定将哪个处于挂起状态的进程重新调入内存。
* 引入了虚拟内存技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。这么做的目的是为了**提高内存利用率和系统吞吐量**。
* 暂时调到外存等待的进程状态为**挂起状态**。值得注意的是，**PCB** 并不会一起调到外存，而是**会常驻内存**。因为 PCB 中会记录进程数据在外存中的存放位置、进程状态等信息，操作系统通过内存中的 PCB 来保持对各个进程的监控、管理。被挂起的进程 PCB 会被放到**挂起队列**中。
* 一个进程可能会被多次调出、调入内存，因此**中级调度**发生的**频率**要比高级调度**更高**。
* 补充知识：进程的挂起态和七状态模型
![图示](https://img-blog.csdnimg.cn/518052d79ee8430a8082868d709e1421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 为减轻系统负载，提高资源利用率，**暂时不执行的进程会被调到外存从而变为挂起态。**
#### 低级调度
* **低级（进程）调度**：其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。
* 进程调度是操作系统中**最基本的一种调度**，在一般的操作系统中都必须配置进程调度。
* 进程调度的**频率很高**，一般几十毫秒一次。
#### 三层调度的联系、对比
![图示](https://img-blog.csdnimg.cn/d6b50106bc454909be04ad3b2c383716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 2.7 进程调度
* **进程调度（低级调度）**：就是按照某种算法从就绪队列中选择一个进程为其分配处理机。
#### 进程调度的时机
![图示](https://img-blog.csdnimg.cn/8fa8635822f141398c61ee5d82310aa5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 有的系统中，只允许进程主动放弃处理机；有的系统中，进程可以主动放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机（被动放弃）
* **临界资源**：一个时间段内只允许一个进程使用的资源。各进程需要**互斥地**访问临界资源。
* **临界区**：访问临界资源的那段代码。
* 另：**临界区：** 是访问共享资源的代码片段，一定不能由多个进程同时执行。**临界资源是一种共享资源。**
* 进程在**操作系统内核程序临界区**中**不能**进行调度与切换。**内核程序临界区**一般是用来访问**某种内核数据结构**的，比如进程的就绪队列（由各就绪进程的 PCB 组成）
* 进程处于**临界区**时**可以**进行处理机的调度与切换。
#### 进程调度的方式
![图示](https://img-blog.csdnimg.cn/1acca9b1eb234daa9f7fee9971d86e02.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 进程的切换与过程
![图示](https://img-blog.csdnimg.cn/92ef77806a174b4595e0a36347f14d60.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 2.8 调度算法的评价指标
![图示](https://img-blog.csdnimg.cn/c626a11fcbe9436194bb829be7de0aef.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### CPU 利用率
* **CPU 利用率**：指 CPU “忙碌”的时间占总时间的比例。
* 由于早期的 CPU 造价昂贵，因此人们会希望让 CPU 尽可能多地工作。
![图示](https://img-blog.csdnimg.cn/b95a535eedb54dc8ba66eea71ca35016.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 系统吞吐量
* **系统吞吐量**：指单位时间内完成作业的数量。
* 对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业。
![图示](https://img-blog.csdnimg.cn/07acf00cd81942e6a4957a4cecab8640.png)
#### 周转时间
* **周转时间**：指**作业被提交到系统开始**，到**作业完成为止**的这段时间间隔，即**作业从提交到完成所花费的时间**。
* 计算机的用户很关心自己的作业从提交到完成花费了多少时间。
* 它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在 CPU 上执行的时间、进程等待 I/O 操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。
![图示](https://img-blog.csdnimg.cn/680677265d574afe910a02fa40774f8b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 带权周转时间的理解：两个人上厕所，一个人上9分钟等1分钟和一个人上1分钟等9分钟，总时间一样，但是前者的感受肯定比后者好。
#### 等待时间
* **等待时间**：指进程/作业**处于等待处理机状态的时间之和**，等待时间越长，用户满意度越低。
* 计算机的用户希望自己的作业尽可能少的等待处理机。
* 对于**进程**来说，**等待时间 = 进程建立后等待被服务的时间之和**，在等待 I/O 完成的期间其实进程也是在被服务的，所以不计入等待时间。
* 对于**作业**来说，**等待时间 = 建立进程后的等待时间 + 作业在外存后备队列中等待的时间。**
* 一个作业总共需要被 CPU 服务多久，被 I/O 设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。
#### 响应时间
* **响应时间**：指用户**提交请求**到**首次产生响应**所用的时间。
* 对于用户来说，会希望自己提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应。
### 2.9 调度算法（适用早期批处理系统）
* **饥饿：某进程/作业长期得不到服务。**
#### 先来先服务算法（FCFS，First Come First Serve）
![图示](https://img-blog.csdnimg.cn/3b328d8d3f5847a6a1abe5ec78adcbf5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 短作业优先算法（SJF，Shorest Job First）
* 非抢占式：短进程/作业优先调度算法（SPF/SJF）
* 抢占式：最短剩余时间优先算法（SRTN）
* 短作业/进程优先调度算法：每次调度时选择**当前已到达**且**运行时间最短**的作业/进程。
* 最短剩余时间优先算法：每当有新的进程加入就绪队列时，会引发就绪队列改变，当**就绪队列改变时就需要调度**，如果新到达的进程的**剩余时间**比当前运行的进程的剩余时间**更短**，则有新进程**抢占**处理机，当前运行进程重新回到就绪队列。另外，当一个**进程完成时也需要调度。**
![图示](https://img-blog.csdnimg.cn/3d8cdae4bf6c4cbc8956db0b2cf7baaf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 注意几个细节：
![图示](https://img-blog.csdnimg.cn/984ac80d24b246febbf4203596c579f7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 对 FCFS 和 SJF 两种算法的思考
* FCFS 算法是在每次调度的时候选择一个等待时间最长的作业（进程）为其服务。但是没有考虑到作业的运行时间，因此导致了对短作业不友好的问题
* SJF 算法是选择一个执行时间最短的作业为其服务，但是又完全不考虑各个作业的等待时间，因此导致了对长作业不友好的问题，甚至还会造成饥饿问题。
#### 高响应比优先（HRRN，Highest Response Ratio Next）
![图示](https://img-blog.csdnimg.cn/820fd5d1d6be41f7a50fbf9b4816645d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* **高响应比优先**算法：**非抢占式**的调度算法，只有当前运行的进程**主动放弃 CPU 时**（正常/异常完成，或主动阻塞），才需要进行调度，调度时**计算所有就绪进程的响应比**，**选响应比最高的进程**上处理机。
#### 小结
![图示](https://img-blog.csdnimg.cn/712705bd2e2747a18168fa4f2d37f97a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 2.10 调度算法（适用交互式系统）
#### 时间片轮转算法（RR）
*  时间片轮转调度算法：轮流让就绪队列中的进程依次执行一个时间片（每次选择的都是排在就绪队列队头的进程）
![图示](https://img-blog.csdnimg.cn/4598c3f57992420a84e065be6903fd84.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 如果**时间片太大**，使得每个进程都可以在一个时间片内就完成，则**时间片轮转调度算法退化为先来先服务调度算法**，并且会增大进程响应时间，因此时间片不能太大。
* 另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果**时间片太小**，会导致**进程切换过于频繁**，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。
* 一般来说，设计时间片时让切换进程的开销占比不超过1%。
#### 优先级调度算法
* 非抢占式的优先级调度算法：每次调度时选择**当前已到达**且**优先级最高**的进程。当前进程**主动放弃处理机**时发生调度。
* 抢占式的优先级调度算法：每次调度时选择**当前已到达**且**优先级最高**的进程。当前进程**主动放弃处理机**时发生调度。另外，当**就绪队列发生改变时**也需要检查是否会发生抢占。
![图示](https://img-blog.csdnimg.cn/d2f489c7fc694ccaad8410ebd33838aa.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/69e4e3f81dea47f1b72273f61f4077f8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 多级反馈队列算法
* 多级反馈队列算法：
（1）设置多级就绪队列，各级队列**优先级从高到低，时间片从小到大**
（2）**新进程**到达时**先进入第 1 级队列**，按 **FCFS 原则**等待被分配时间片。若用完时间片进程还未结束，则进程进入**下一级队列队尾**。如果此时**已经在最下级**的队列，则**重新放回**最下级队列队尾。
（3）只有**第 k 级队列为空**时，才会**为 k + 1 级队头的进程分配时间片**。
（4）**被抢占处理机**的进程**重新放回原队列**队尾。

![图示](https://img-blog.csdnimg.cn/ac88733d21ed4be9825e2522d832d470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 三种算法的对比
![图示](https://img-blog.csdnimg.cn/b7188864c3384416a2c2db33b01d98af.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 2.11 进程同步、进程互斥
#### 进程同步
* 管道通信中，读进程和写进程并发地运行，由于并发必然导致**异步性**，因此“写数据”和“读数据”两个操作的先后顺序是不确定的。而实际应用中，又必须按照“写数据 -> 读数据”的顺序来执行，因此如何解决这种异步问题，就是“进程同步”所要讨论的问题。
* **同步**亦称**直接制约关系**，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上**协调它们的工作次序**而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。
* 进程同步：要让各并发进程有序地推进。
* **所谓进程同步其实就是要保证某些操作要一前一后地执行**。
#### 进程互斥
* 我们把**一个时间段内只允许一个进程使用**的资源称为**临界资源**。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。

* 对临界资源的访问，必须**互斥**地进行。互斥，亦称**间接制约关系**。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。
![图示](https://img-blog.csdnimg.cn/bb005bf624d04c90b4f490a3d1093956.png)
![图示](https://img-blog.csdnimg.cn/4338c8b67af349498d71d94b0872034e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 为了实现对**临界资源的互斥访问**，同时保证系统整体性能，需要遵循以下原则：
（1）**空闲让进。** 临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。
（2）**忙则等待。** 当已有进程进入临界区时，其他试图进入临界区的进程必须等待。
（3）**有限等待。** 对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）。
（4）**让权等待。** 当进程不能进入临界区时，应立即释放处理机，防止进程忙等。
#### 同步和互斥的区别
1. 互斥是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。
2. 同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。
3. 同步其实已经实现了互斥，所以同步是一种更为复杂的互斥。
4. 互斥是一种特殊的同步。
5. 也就是说互斥是两个进程之间不可以同时运行，他们会相互排斥，必须等待一个进程运行完毕，另一个才能运行；而同步也是不能同时运行，但它是必须要按照某种次序来运行相应的进程（也是一种互斥）。
### 2.12 进程互斥的软件实现方法
#### 单标志法
* 算法思想：两个进程在**访问完临界区后**会把使用临界区的权限交给另一个进程。也就是说**每个进程进入临界区的权限只能被另一个进程赋予。**
![图示](https://img-blog.csdnimg.cn/823a7d661b054725abbe3538b0ec5b3a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 存在的问题：turn 表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程在访问了临界区之后，才会改变 turn 的值。也就是说，对于临界区的访问，一定是按 P0 -> P1 -> P0 -> P1... 这样轮流访问。这种必须轮流访问带来的问题是：如果此时允许进入临界区的进程是 P0，而 P0 一直不访问临界区，那么虽然此时临界区空闲，但是并不允许 P1 访问。因此，**单标志法存在的主要问题是：违背”空闲让进“原则。** 
#### 双标志先检查法
* 算法思想：设置一个布尔型数组 flag[]，数组中各个元素用来**标记个进程想进入临界区的意愿**，比如：“flag[0] = true” 意味着 0 号进程 P0 现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标指 flag[i] 设为 true，之后开始访问临界区。
![图示](https://img-blog.csdnimg.cn/e5e825e57cca44838b21e71e24f45942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 双标志后检查法
* 算法思想：双标志先检查法的改版，前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。
![图示](https://img-blog.csdnimg.cn/69a7f47145264e84aae64144dcdb9151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### Peterson 算法
* 算法思想：双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。GaryL.Peterson 想到了一种方法，如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方先使用临界区。
![图示](https://img-blog.csdnimg.cn/457187f7c1ab47638f17b2dfda904692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 存在的问题：Peterson 算法用软件方法解决了进程互斥问题。**遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则。**
### 2.13 进程互斥的硬件实现方法
#### 中断屏蔽方式
![图示](https://img-blog.csdnimg.cn/bb6b90cae8e441cd8e65df2f94d034b7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### TestAndSet 指令
![图示](https://img-blog.csdnimg.cn/a40eee7df2314e60aa46f69dbdf55020.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### Swap 指令
![图示](https://img-blog.csdnimg.cn/9f7bab9c41e240188959497b49bd4b74.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 2.14 信号量机制
* 用户进程可以通过使用操作系统提供的**一对原语来对信号量进行操作**，从而很方便地实现了进程互斥、进程同步。
* **信号量**其实就是一个变量（**可以是一个整数，也可以是更复杂的记录型变量**），可以用一个信号量来**表示系统中某种资源的数量**，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量。
* 原语是一种特殊的程序段，其**执行只能一气呵成，不可被中断**，原语是由**关中断/开中断指令**实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”，就能避免问题。
* **一对原语**：**wait(S) 原语和 signal(S) 原语**，可以把原语理解为我们自己写的函数，函数名分别为 wait 和 signal，括号里的**信号量 S** 其实就是函数调用时传入的一个参数。
* wait 和 signal 原语经常**简称为 P、V 操作**。因此，经常把 wait(S) 和 signal(S) 两个操作分别写为 P(S) 和 V(S) 。
#### 整型信号量
![图示](https://img-blog.csdnimg.cn/1698f9ded8d14410ad8488a56c22c9bb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 记录型信号量
![图示](https://img-blog.csdnimg.cn/2b13b6cc041f4697b65ad8e1ca59ef83.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 2.15 用信号量实现进程互斥、进程同步、前驱关系
#### 信号量实现进程互斥
* 进程互斥指**当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待**。临界资源：一个时间段内只允许一个进程使用的资源称为临界资源。
![图示](https://img-blog.csdnimg.cn/00d60e8505224b5e8dc8e023fcea6e0e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 信号量实现进程同步
* 进程同步（一前一后）：要让各并发进程按要求有序地推进。
* 所谓进程同步其实就是要保证某些操作要**一前一后**地执行。
* 示例：
![图示](https://img-blog.csdnimg.cn/2087f6038e044f50834a5d018b7b299a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 如何实现进程同步：
![图示](https://img-blog.csdnimg.cn/164fec6337714e93bdddf25d84b8f35c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 信号量实现前驱关系
* 问题：进程 P1 中有句代码 S1，P2 中有句代码 S2 ... P6 中有句代码 S6，这些代码要求按如下前驱图所示的顺序来执行：
![图示](https://img-blog.csdnimg.cn/78bf8190ed0e4da2b72d95b097791342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 2.16 生产者-消费者问题
#### 问题描述与分析：
![图示](https://img-blog.csdnimg.cn/1064b1e211e64cb7af6798dd43babdbd.png)
#### 如何使用信号量机制（P、V 操作）实现生产者、消费者进程的这些功能：
* 信号量机制可以实现**互斥、同步、对一类系统资源的申请和释放**。
（1）互斥：设置初始值为 1 的互斥信号量。在临界区前后分别 P、V。
（2）同步：设置初始值为 0 的同步信号量（实现“一前一后”）。前 V 后 P。
（3）对一类系统资源的申请和释放：设置一个信号量，初始值即为资源的数量（本质上也属于“同步问题”），若无空闲资源，则申请资源的进程需要等待别的进程释放资源后才能继续往下执行。
#### 具体实现：
![图示](https://img-blog.csdnimg.cn/3f5a6b378cef40129fdfe954054105c0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 能否改变相邻 P 或者 相邻 V 操作的顺序：
![图示](https://img-blog.csdnimg.cn/81207c8525e843c0aa0deff0b52a41dd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 小结
![图示](https://img-blog.csdnimg.cn/8011f965cc28462a973cc5596ec52aa5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 2.17 多生产者-多消费者问题
#### 问题描述与分析：
![图示](https://img-blog.csdnimg.cn/982af6942f0e48848020ab2f5210f8b5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 如何实现
![图示](https://img-blog.csdnimg.cn/03620f7393aa4a7aa141cc79ca309003.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 注意事项
在多生产者-多消费者问题中，如果**缓冲区大小为 1**，那么**有可能**不需要设置互斥信号量就可以实现互斥访问缓存区的可能。但这不是绝对的，需要具体问题具体分析。

如果缓存区大小大于 1，那么可能出现两个进程同时访问缓存区的可能，有可能导致两个进程写入缓存区的位置相同，从而导致这两个进程写入缓存区的数据相互覆盖的情况，因此，如果**缓存区大小大于 1**，就**必须专门设置一个互斥信号量** mutex 来保证互斥访问缓存区。

**实现互斥的 P 操作一定要在实现同步的 P 操作之后，否则可能引起“死锁”。**
### 2.18 吸烟者问题
#### 问题描述与分析
![图示](https://img-blog.csdnimg.cn/f2b447f2a3bd474ca11a4e978f5e6e0f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 如何实现
![图示](https://img-blog.csdnimg.cn/aca9fe781ddd446dbf5c688ff2230be1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 小结
吸烟者问题可以为我们解决“**可以生产多个产品的单生产者**”问题提供一个思路。若一个生产者要生产多种产品（或者说会引发多种前驱事件），那么**各个 V 操作应该放在各自对应的“事件”发生之后的位置**。
### 2.19 读者-写者问题
#### 问题分析与描述
![图示](https://img-blog.csdnimg.cn/8328f62896774de28bc88851352daa11.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
（1）两个写进程同时共享数据，可能导致数据覆盖的问题。
（2）读进程和写进程同时共享数据，可能导致读出的数据不一致的问题。
（3）与消费者进程不同，读者进程在读数据后并不会将数据清空，并不会改变数据，因此多个读者进程可以同时访问共享数据。
#### 如何实现
![图示](https://img-blog.csdnimg.cn/a5b42237e467478381f2da466ecabbf1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/bcdf7007220845d8a1d4945bfd0db5d3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 小结
读者-写者问题为我们解决复杂的互斥问题提供了一个思路。”问题提供一个思路。

其**核心思想**在于设置了一个**计数器 count** 用来记录当前正在访问共享文件的读进程数。我们可以用 count 的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。

另外，对 count 变量的检查和赋值不能一气呵成导致了一些错误，如果**需要实现“一气呵成”，自然应该想到用互斥信号量。**

### 2.20 哲学家进餐问题
#### 问题分析与描述
![图示](https://img-blog.csdnimg.cn/bd32df94762448c39813521dc12c90b1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 比如：当每个哲学家同时拿起左边的筷子的时候，可能会出现“死锁”现象。那么如何解决死锁现象呢？
（1）可以对哲学家进程施加一些限制，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。
（2）要求奇数号的哲学家先拿起左边的筷子，然后再拿右边的筷子，而偶数号哲学家则刚好相反。用这种方式可以保证，如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一支筷子，另一个会直接阻塞。这样就避免了占有一只后再等待另一只的情况。
（3）各个哲学家拿筷子这件事必须互斥地执行。这样就保证了即使一个哲学家在拿筷子拿到一半的时候阻塞，也不会有别的哲学家会继续尝试拿筷子，这样的话，当前正在吃饭的哲学家放下筷子后，被阻塞的哲学家就可以获得等待的筷子了。
#### 如何实现
方法（3）的实现方式：
![图示](https://img-blog.csdnimg.cn/39419a9dc6a64c02bd8dfd2c25ba6466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 小结
哲学家进餐问题的关键在于解决进程死锁问题。
### 2.21 管程
* 信号量机制存在的问题：程序编写困难，易出错
#### 管程的定义和基本特征
![图示](https://img-blog.csdnimg.cn/8755d055f2d3420e90bbf5b4386f7e66.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 用管程解决消费者-生产者问题
![图示](https://img-blog.csdnimg.cn/f161dbbc06be47e894a1311a59c54536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/683d4162bae44d07bbcb815c7c064b81.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### Java 中类似于管程的机制
![图示](https://img-blog.csdnimg.cn/57de48db80494cffb196faed50285d05.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 2.22 死锁的概念
#### 什么是死锁？
在并发环境下，各进程因竞争资源而造成的一种**互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”**。发生死锁后若无外力干涉，这些进程都将无法向前推进。
#### 死锁、饥饿、死循环的区别
* 死锁：各进程相互等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。
* 饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先（SPF）算法中，若有源源不断的短进程进来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。
* 死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑 bug 导致的，有时是程序员故意设计的。
![图示](https://img-blog.csdnimg.cn/28c0cea31b834da4be024bace0ae48fa.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 死锁产生的必要条件
![图示](https://img-blog.csdnimg.cn/2fbfff679b664490890a229f12b3d60a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 什么时候会发生死锁
（1）**对系统资源的竞争。** 各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（如 CPU）的竞争是不会引起死锁的。

（2）**进程推进顺序非法。** 请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程 P1、P2 分别申请并占有了资源 R1、R2，之后进程 P1 又紧接着申请资源 R2，而进程 P2 又申请资源 R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。

（3）**信号量的使用不当也会造成死锁。** 如生产者-消费者问题中，如果实现互斥的 P 操作在实现同步的 P 操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源。）

**总之：对不可剥夺资源的不合理分配，可能导致死锁。**
#### 死锁的处理策略
（1）预防死锁。破坏死锁产生的四个必要条件中的一个或几个。
（2）避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）
（3）死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。
### 2.23 死锁的处理策略-预防死锁
#### 破坏互斥条件
![图示](https://img-blog.csdnimg.cn/47a00f70771042e683b24e66a6286d0c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 破坏不剥夺条件
![图示](https://img-blog.csdnimg.cn/94b3b1b3fd2649f9b74c7497027b2e82.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 破坏请求和保持条件
![图示](https://img-blog.csdnimg.cn/2daed56069ec43d3bdb09bcc907de805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 破坏循环等待条件
![图示](https://img-blog.csdnimg.cn/a6646e41ffaf44958f75c9a19d27e3e7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 2.24 死锁的处理策略-避免死锁
#### 安全序列、不安全状态、死锁的联系
* 所谓**安全序列**，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。当然，安全序列可能有多个。
* 只要能找出一个安全序列，系统就是**安全状态**。
* 如果分配了资源之后，系统找不出任何一个安全序列，系统就进入了**不安全状态**。这就意味着之后可能所有进程都无法顺利地执行下去。当然，如果有进程提前归还了一些资源，那**系统也有可能重新回到安全状态**，不过我们在分配资源之前总是要考虑到最坏的情况。
* 如果系统处于**安全状态**，就**一定不会发生死锁**。如果系统进入**不安全状态**，就**可能发生死锁**（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）
* 因此可以**在资源分配之前预先判断这次分配是否会导致系统进入不安全状态**，以此决定是否答应资源分配请求。这也是 **“银行家算法”** 的核心思想。
#### 银行家算法
![图示](https://img-blog.csdnimg.cn/eb6ba757f8794903a7fd38667482d314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/e76e84c705714e38b53978379f68de5a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 2.25 死锁的处理策略-检测和解除
* 如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。在这种情况下，系统应当提供两个算法：
（1）**死锁检测算法**：用于检测系统状态，以确定系统中是否发生了死锁。
（2）**死锁解除算法**：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。
#### 死锁的检测
![图示](https://img-blog.csdnimg.cn/4ab0e3af7cb24a6397d138e7eb6053cd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
如果系统中剩余的可用的资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程...

如果按上述分析，**最终能消除所有的边**，就称这个图是**可完全简化**的。此时**一定没有发生死锁**（相当于能找到一个安全序列）。

如果最终**不能消除所有边**，那么此时就是**发生了死锁**。**最终还连着边的那些进程就是处于死锁状态的进程。**

**死锁定理**：如果某时刻系统的资源分配图是**不可完全简化**的，那么此时系统**死锁**。
#### 死锁的解除
![图示](https://img-blog.csdnimg.cn/82f3dbbc959145d981e2925e038865ad.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
## 三、内存管理
### 3.1 内存的基础知识
#### 什么是内存？有什么作用？
![图示](https://img-blog.csdnimg.cn/967b7aa1b4674abb81f545f9bcf8bcb9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 补充知识：几个常用的数量单位
![图示](https://img-blog.csdnimg.cn/346be40dfaf241fca65b6ce9b8abe8ec.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 进程的运行原理-指令
![图示](https://img-blog.csdnimg.cn/2bf5f20480724a85862ca6d7b00ed1c7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 物理地址和逻辑地址
![图示](https://img-blog.csdnimg.cn/8d20de0cf51a43caa859efa514a0a886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 从写程序到程序运行
![图示](https://img-blog.csdnimg.cn/94f1a9b77336481eaa5b6e7e0c666725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)

#### 装入模块装入内存
![图示](https://img-blog.csdnimg.cn/0a9e773230ea4d529da295cd888c4598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 装入的三种方式（用三种不同的方法完成**逻辑地址到物理地址的转换**）：
（1）绝对装入。
（2）静态重定向。
（3）动态重定向。
#### 装入的第一种方式-绝对装入
![图示](https://img-blog.csdnimg.cn/5ee458c743ec4c15b47d46497b05280d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 装入的第二种方式-静态重定向
![图示](https://img-blog.csdnimg.cn/685b074359d144eea2cf72e26ed8e659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 装入的第三种方式-动态重定位
![图示](https://img-blog.csdnimg.cn/b8d1b3f2fe694420ba763038b909edc0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 这种方式在装入的时候依然保持使用逻辑结构。
* 优点：采用动态重定位时**允许程序在内存内发生移动**。并且可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。
#### 三种装入方式小结
![图示](https://img-blog.csdnimg.cn/296f8809b4f94702bc398518483f0d84.png)
#### 链接的三种方式
* （1）静态链接：在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。
* （2）装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式。
* （3）运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。
### 3.2 内存管理的概念
* 操作系统作为系统资源的管理者，需要对内存进行管理，要管些什么呢？
（1）操作系统负责管理**内存空间的分配与回收**。
（2）操作系统需要提供某种技术**从逻辑上对内存空间进行扩充**。（比如一个游戏大小 60G，但电脑的内存才 4G，采用了**虚拟技术**可以使得这个游戏可以顺利执行。）
（3）操作系统需要提供**地址转换功能**，负责程序的逻辑地址与物理地址的转换。为了编程方便，程序员写程序的时候应该只需要关注指令、数据的逻辑地址，而 **逻辑地址到物理地址的转换**（这个过程叫作**地址重定位**）应由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。
（4）操作系统需要提供**内存保护功能**，保证各进程在各自存储空间内运行，互不干扰。
![图示](https://img-blog.csdnimg.cn/bd20f794f3c74629b4548deb35796a00.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/d5b5601c3aa44b81877bd34e0a9dc183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 内存空间的扩充之覆盖技术
* 早期的计算机内存很小，经常会出现内存大小不够的情况。后来人们引入了**覆盖技术**，用来**解决程序大小超过物理内存总和的问题。**
* 覆盖技术的思想：将**程序分为多个段**（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。
* 内存中分为**一个固定区**和**若干个覆盖区**。
* 不常用的段放在**覆盖区**，**需要用到时调入内存，用不到时调出内存。**
#### 覆盖技术
![图示](https://img-blog.csdnimg.cn/b5d5d8d4d2db4e29a857b7a81cf14c55.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 内存空间的扩充之交换技术
![图示](https://img-blog.csdnimg.cn/09059f14934e45ca8656c6165031c1c1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/a5c9e16a1b654ca084b60e04d59076f3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 小结
* **覆盖与交换的区别**：覆盖是在同一个程序或进程中的，而交换是在不同进程（或作业）之间的。

### 3.3 连续分配管理方式
* **连续分配**：指为用户进程分配的必须是一个**连续的内存空间**。
#### 单一连续分配
![图示](https://img-blog.csdnimg.cn/b1f9f6a52ac14b69bb9692f8244e9d1f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 固定分区分配
![图示](https://img-blog.csdnimg.cn/50df2deac17c4c849c992682bb66ec91.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/ac1a09b26e064cf9a5668a98b6a6174c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 动态分区分配
* **动态分区分配**又称为**可变分区分配**。这种分配方式**不会预先划分内存分区**，而是在进程装入内存时，**根据进程的大小动态地建立分区**，并使分区的大小正好适合进程的需要。因此系统当中内存分区的大小和数目是可变的。
* 动态分区分配**没有内部碎片，但是有外部碎片。**
**内部碎片**：分配给某进程的内存区域中，如果有些部分没有用上。
**外部碎片**：是指内存中的某些空闲分区由于太小而难以利用。
* 如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些碎片不能满足进程的需求。可以通过**紧凑（拼凑）** 技术来解决外部碎片。
* 动态分区分配方式应该采用**动态重定位的装入方式**。
![图示](https://img-blog.csdnimg.cn/5893691b68cc4fa1978232a35dd5ebf7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/c5482fa960514e90899d31daee9d798a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 3.4 动态分区分配算法
#### 首次适应算法
* **算法思想**：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。
* **如何实现**：**空闲分区以地址递增的次序排序**。每次分配内存时顺序查找**空闲分区链**（或**空闲分区表**），找到大小能满足要求的第一个空闲分区。
#### 最佳适应算法
* **算法思想**：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能地多留下大片的空闲区，即：优先使用更小的空闲区。
* **如何实现**：**空闲分区按容量递增的次序链接**。每次分配内存时顺序查找**空闲分区链**（或**空闲分区表**），找到大小能满足要求的第一个空闲分区。
* **缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方式会产生很多的外部碎片。**
#### 最坏适应算法（最大适应算法）
* **算法思想**：为了解决最佳适应算法的问题--即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。
* **如何实现**：**空闲分区按容量递减的次序链接**。每次分配内存时顺序查找**空闲分区链**（或**空闲分区表**），找到大小能满足要求的第一个空闲分区。
* **缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大、更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。**
#### 邻近适应算法
* **算法思想**：首次适应算法每次都从链头开始，这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找使，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。
* **如何实现**：**空闲分区以地址递增的顺序排序（可排成一个循环列表）**。每次分配内存时**从上次查找结束的位置开始**查找**空闲分区链**（或**空闲分区表**），找到大小能满足要求的第一个空闲分区。
* 首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来（最佳适应算法的优点）
* 邻近适应算法的规则可能会导致无论低地址、高地址的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点）
#### 小结
综合来看，**四种算法中，首次适应算法的效果更好。**
![图示](https://img-blog.csdnimg.cn/6a573b9f81734798876922e197df27fc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 3.5 基于分页存储管理
#### 连续分配方式的缺点
* 考虑支持多道程序的两种连续分配方式：
（1）固定分区分配：缺乏灵活性，会产生大量的内部碎片，内存的利用率很低。
（2）动态分区分配：会产生很多外部碎片，虽然可以用“紧凑” 的技术来处理，但是“紧凑”的时间代价很高。
* **非连续分配（离散分配）**：为用户进程分配的可以是一些分散的内存空间。即**允许将一个进程分散地装入到许多不相邻的分区中**。
#### 把“固定分区分配”改造为“非连续分配版本”
![图示](https://img-blog.csdnimg.cn/6c4ce419d2184c61ae6ba2d5a613357c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 分页存储管理的基本概念
![图示](https://img-blog.csdnimg.cn/caaefd99e6a040f5bba07649fa95f186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 分页存储管理中，如何实现进程从逻辑地址到物理地址的转换
* 地址转换的步骤：
（1）算出逻辑地址对应的**页号**。
（2）知道该页号对应**页面在内存中的起始地址**。
（3）算出逻辑地址**在页面内的“偏移量”**。
（4）**物理地址 = 页面始址 + 页内偏移量。**
* 如何计算：
（1）**页号** = 逻辑地址 / 页面长度（取除法的**整数**部分）
（2）**页内偏移量** = 逻辑地址 % 页面长度（取除法的**余数**部分）
（3）页面在**内存中的起始位置**：操作系统需要用某种数据结构记录进程各个页面的起始位置。
* 为了方便计算页号、页内偏移量，**页面大小**一般设置为 **2 的整数幂**。
* 如果每个页面大小为 $2^K$，用二进制数表示逻辑地址，则末尾 K 位即为**页内偏移量**，其余部分就是**页号**。因此，如果让每个页面的大小为 2 的整数幂，计算机就可以很方便地得出一个逻辑地址对应的页号和页内偏移量。
#### 逻辑地址结构
![图示](https://img-blog.csdnimg.cn/fa305454ea4648ebb8d98a929cd83b8d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 页表
![图示](https://img-blog.csdnimg.cn/7ce9ce850037490b9cdb8bc8dc4289b9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 页表其实就是让我们知道**页面在内存中的起始地址**。
* 各页表项会**按顺序连续地**存放在内存中。如果该页表在内存中存放的起始地址为 X，则 M 号页对应的页表项一定是存放在内存地址为 X + 3 * M。因此，页表中的页号可以是“隐含”的。
* 只需要知道**页表存放的起始地址**和**页表项长度**，就可以找到各个页号对应的页表项存放的位置。
### 3.6 基本地址变换机构
* 基本地址变换机构：**用于实现逻辑地址到物理地址转换的一组硬件机构。**
* 基本地址变换结构可以借助**进程的页表**将逻辑地址转换为物理地址。
* 通常会在系统中设置一个**页表寄存器**（PTR），存放**页表在内存中的起始地址 F 和页表长度 M**。**进程未执行**时，页表的始址和页表长度**放在进程控制块（PCB）** 中，当**进程被调度**时，操作系统内核会把它们**放到页表寄存器中**。
#### 逻辑地址到物理地址的变换过程
![图示](https://img-blog.csdnimg.cn/4a2d4a5fd0734dedb29e5d6b451ae0ba.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 例题
![图示](https://img-blog.csdnimg.cn/6806259d3eff44d9a9aa753c1ccc35e1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 3.7 基本快表的地址变换机构
#### 局部性原理
![图示](https://img-blog.csdnimg.cn/5ee7f132056343c1bcc31e11e0288cd8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 什么是快表
* **快表**：又称**联想寄存器（TLB）**，是一种**访问速度比内存快很多**的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为**慢表**。
#### 引入快表后，地址的变换过程
![图示](https://img-blog.csdnimg.cn/031e02a5d00a4703932044bd312e3a5e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 小结
![图示](https://img-blog.csdnimg.cn/e917489b59d24f35ade308d1aa34829c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 3.8 两级页表
#### 单页表存在的问题
（1）**所有页表项必须连续存放**，页表过大时需要很大的连续空间。
（2）在一段时间内并非所有页面都用得到，因此没必要让整个页表常驻内存。
#### 两级页表的原理、地址结构
要为离散分配的页表再建立一张页表，称为**页目录表，或称外层页表、顶层页表。**
![图示](https://img-blog.csdnimg.cn/94d107cd67aa49998ba73b4b4d70f1f4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 如何实现地址变换
* 步骤：
（1）按照地址结构将逻辑地址拆分为三部分。
（2）从 PCB 中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置。
（3）根据二级页号查表，找到最终想访问的内存块号。
（4）结合页内偏移量得到物理地址。
![图示](https://img-blog.csdnimg.cn/97c7e9330b1d4726a931a3e271bc34d8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 需要注意的细节
![图示](https://img-blog.csdnimg.cn/6b444183ba8c4ef19a2ee602a23c5f40.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 3.9 基本分段存储管理
#### 分段
![图示](https://img-blog.csdnimg.cn/fdb1f9514cb7453180ac9491820c2c13.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 分段系统的逻辑地址结构
![图示](https://img-blog.csdnimg.cn/a24cd5fa2a9d479588f1c01ab5484ff8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 段表
![图示](https://img-blog.csdnimg.cn/c506b7ccfb52467393f2619e2e791a67.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 地址变换
![图示](https://img-blog.csdnimg.cn/a7495a83fb5c4569b28f632dcfd399f4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 分段和分页的对比
![图示](https://img-blog.csdnimg.cn/f07e2dee033f40d29e8e061700c5c7e9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bSU5rOi5rOi5ZWK,size_20,color_FFFFFF,t_70,g_se,x_16)
### 3.10 段页式管理
#### 分页、分段的优缺点分析
![图示](https://img-blog.csdnimg.cn/d276c763a94a44d196ece8b5a8881ea8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 分段 + 分页 = 段页式管理
![图示](https://img-blog.csdnimg.cn/40216c9962b54ab0bf57e0ad308989fc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 段页式管理的逻辑地址结构
![图示](https://img-blog.csdnimg.cn/18b27825929743018caf44320840fe17.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 段表、页表
![图示](https://img-blog.csdnimg.cn/e31f19b736d7457dbc5e705780df9cc8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 地址变换
![图示](https://img-blog.csdnimg.cn/445839b1528849658285b9835c869a0f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 访问一个逻辑地址所需访存次数：第一次-查段表，第二次-查页表，第三次-访问目标单元。可引入快表机制，以段号和页号为关键字查询快表，即可直接找到最终的目标页面存放位置，引入快表后仅需一次访存。
### 3.11 虚拟存储的基本概念
#### 传统存储管理方式的特征、缺点
![图示](https://img-blog.csdnimg.cn/1b42fe72317a4137834c78c7b6b73420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 局部性原理
![图示](https://img-blog.csdnimg.cn/ab41f80f243f4e64a25a2c3482ac975f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 虚拟内存的定义和特征

![图示](https://img-blog.csdnimg.cn/58ab4b29eb964425aa7b16fcf4f2b6cc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 虚拟内存有以下三个主要特征：
（1）**多次性：** 无需在作业运行时一次性全部装入内存，而是允许被分成多次调用内存。
（2）**对换性：** 在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。
（3）**虚拟性：** 从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。

#### 如何实现虚拟内存技术
![图示](https://img-blog.csdnimg.cn/0f0902518e3a4d54845484290fbce4ad.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 3.12 请求分页管理方式
* 请求分页存储管理与基本分页存储管理的主要区别：
（1）在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。（**操作系统需要提供请求调页功能，将缺失页面从外存调入内存**）。
（2）若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。（**操作系统要提供页面置换的功能，将暂时用不到的页面换出到外存**）
#### 页表机制
![图示](https://img-blog.csdnimg.cn/f6ab16059ec94057b3e3949bb67085f8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 缺页中断机构
![图示](https://img-blog.csdnimg.cn/f2521c2ad73c47b4b87b539f0554bd7b.png)
![图示](https://img-blog.csdnimg.cn/6811f2e1c57a4b298cf9356e4b97b72d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 地址变换机构
* **与基本分页不同的地方**：
（1）找到页表项时需要检查页面是否在内存中。
（2）若页面不在内存中，需要请求调页。
（3）若内存空间不够，需要换出页面。
（4）页面调入内存后，需要修改对应的页表项。
![图示](https://img-blog.csdnimg.cn/128609c74f994ef09006635cb2584c20.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 3.13 页面置换算法
* 页面置换算法是用来决定将哪个暂时用不到的信息换出到外存。
* 注：**页面的换入、换出**需要磁盘 I/O ，**会有较大的开销**，因此**好的页面置换算法**应该追求**更少的缺页率**，也就是**让换入、换出的次数尽可能的少**。
#### 最佳置换算法（OPT）
* 最佳置换算法（Optimal）：每次选择**淘汰的页面**都是**以后永不使用**，或者**在最长时间内不再被访问的页面**，这样可以保证最低的缺页率。
* 最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，**最佳置换算法是无法实现的**。
* **注意：** 缺页时未必发生页面置换。若还有可用的空闲内存块，就不用进行页面置换。
#### 先进先出置换算法（FIFO）
* 先进先出置换算法（FIFO）：每次选择**淘汰的页面**是**最早进入内存的页面。**
* 实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。
* **只有 FIFO 算法会产生 Belady 异常**。另外，FIFO 算法虽然**实现简单**，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，**算法性能差**。
* **Belady 异常：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。**
#### 最近最久未使用置换算法（LRU）
![图示](https://img-blog.csdnimg.cn/043f70b968684778a8ba7ff42943ef04.png)
#### 时钟置换算法（CLOCK）
![图示](https://img-blog.csdnimg.cn/0c5172b8bd7f475d8c78218d2bc91139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 改进型的时钟置换算法
![图示](https://img-blog.csdnimg.cn/bbea12e8b1e34ece927321c62648c364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 小结
![图示](https://img-blog.csdnimg.cn/2bf7b7b30b90475db449c06bad0eae45.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 3.14 页面分配策略
#### 页面分配、置换策略
![图示](https://img-blog.csdnimg.cn/5a4a20644d124a4c902ff80237960e7f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/4eea6d13a79e45e2a31bbf99a362ad8c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 何时调入页面
* （1）预调页策略：根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有 50% 左右。故这种策略**主要用于进程的首次调入（运行前调入）**，由程序员指出应该先调入哪些部分。
* （2）请求调页策略：进程**在运行期间发现缺页时才将所缺页面调入内存（运行时调入）**。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘 I/O 操作，因此 I/O 开销较大。
#### 从何处调入页面
![图示](https://img-blog.csdnimg.cn/658abd56868743aba59cd0482b1a52fc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 抖动（颠簸）现象
![图示](https://img-blog.csdnimg.cn/c1cb03d189e2405abbbad4364cb4890b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 工作集
![图示](https://img-blog.csdnimg.cn/894835dfc60249cdbfcf0f4b3caae9b8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
## 四、文件管理
### 4.1 初识文件管理
* 文件的定义：一组有意义的信息的集合。
#### 文件的属性
* 一个文件有哪些属性？
（1）**文件名**：由创建文件的用户决定文件名，主要是为了方便用户找到文件，**同一目录下不允许有重名文件。**
（2）**标识符**：一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。
（3）**类型**：指明文件的类型。
（4）**位置**：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）
（5）**大小**：指文件的大小。
（6）**创建时间、上次修改时间**。
（7）**文件所有者信息**。
（8）**保护信息**：对文件进行保护的访问控制信息。
#### 文件内部的数据如何组织（文件的逻辑结构）
![图示](https://img-blog.csdnimg.cn/b45a5e2ead134c758df477bd52c18b4f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/c3287aca9ec64b6b9156e3aa29e0d38f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 文件之间如何组织（目录结构）
![图示](https://img-blog.csdnimg.cn/35cce123b14b4feb9073bff1a676a4fb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 操作系统应该向上提供哪些功能
![图示](https://img-blog.csdnimg.cn/a560af6ea79c4443bf4c04f5c096eed6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 从上往下看，文件应该如何存放在外存（文件的物理结构）
![图示](https://img-blog.csdnimg.cn/2f7d516b84414c92a48754d3c534df6b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 其它需要由操作系统实现的文件管理功能
* 文件共享：使多个用户可以共享使用一个文件。
* 文件保护：如何保证不同的用户对文件有不同的操作权限。
### 4.2 文件的逻辑结构
按文件是否有结构分类，可以分为无结构文件、有结构文件两种。
![图示](https://img-blog.csdnimg.cn/e041f9d8a3a04050931c380dbae66e68.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 无结构文件
* **无结构文件**：文件内部的数据就是一系列二进制流或字符流组成，又称“**流式文件**”。如：Windows 操作系统里的 .txt 文件。
* 文件内部的数据其实就是一系列字符流，没有明显的结构特征，因此也不用探讨无结构文件的“逻辑结构”问题。
#### 有结构文件的逻辑结构
![图示](https://img-blog.csdnimg.cn/3ff8374910104578a24709063a8c1b42.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 顺序文件
![图示](https://img-blog.csdnimg.cn/9216d43808384151a58494cd08f65338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/01422e24bdea484fac9396cd1e37f4f2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 最大缺点：不方便增加/删除记录。
#### 索引文件
* 建立一张索引表，每个记录对应一个表项。各记录不用保持顺序，方便增加/删除记录。
* 索引表本身就是定长记录的顺序文件，一个索引表项就是一条定长记录，因此索引文件支持随机存取。
* 若索引表按关键字顺序排列，则可支持快速检索。
* 解决了顺序文件不方便增/删记录的问题，同时让不定长记录的文件实现了随机存取，但索引表可能占用很多空间。
![图示](https://img-blog.csdnimg.cn/88882b43585b459f8915aef13ef80d71.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 索引顺序文件
* 将记录分组，每组对应一个索引表项。
* 检索记录时先顺序查索引表找到分组，再顺序查找分组。
* 当记录过多时，可建立多级索引表。
![图示](https://img-blog.csdnimg.cn/915d58cd092944deb72d2496e63ae093.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 多级索引顺序文件
![图示](https://img-blog.csdnimg.cn/9ffe8669b123496fb5ad5542f2d8ba32.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 4.3 文件目录
* **目录本身就是一种有结构文件，由一条条记录组成。每条记录对应一个放在该目录下的文件。**
#### 文件控制块
* **目录文件中的一条记录就是一个文件控制块（FCB）**
* FCB 的有序集合称为“文件目录”。一个 FCB 就是一个文件目录项。
* FCB中包含了文件的基本信息（文件名、物理地址、逻辑结构、物理结构等），存取控制信息（是否可读/可写、禁止访问的用户名单等）、实用信息（如文件的建立时间、修改时间等）。
* **最重要、最基本**的还是**文件名、文件存放的物理地址**。
* FCB 实现了文件名和文件之间的映射，使用户（用户程序）可以实现“按名存取”。
* 一个文件对应一个 FCB，一个 FCB 就是一个目录项，多个 FCB 组成文件目录。
![图示](https://img-blog.csdnimg.cn/c746690d10994ca88afde137f9a4d6ad.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 目录结构-单级目录结构
![图示](https://img-blog.csdnimg.cn/79d1628310d04be1885cdb0394e7abe6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 目录结构-两级目录结构
![图示](https://img-blog.csdnimg.cn/2dcd37d1ef8144a0956f1a4f1a61d94e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 目录结构-多级目录结构（树形目录结构）
![图示](https://img-blog.csdnimg.cn/cbfb5f7aa3004e478be75c30ef5156fc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* **树形目录结构**可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护，但是树形结构**不便于实现文件的共享**。于是提出了“无环图目录结构”。
#### 目录结构-无环图目录结构
![图示](https://img-blog.csdnimg.cn/8a74264c87874f06a6fb2004deb6243a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 索引结点（FCB 的改进）
![图示](https://img-blog.csdnimg.cn/f2ee5af51adf43ec8aa8fd72c829fecf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
由于目录项长度减小，因此每个磁盘块可以存放更多的目录项，因此检索文件时 I/O 的次数就少了很多。
### 4.4 文件的物理结构（文件分配方式）
![图示](https://img-blog.csdnimg.cn/2912c702538b477fb52d7259f0284929.png)
![图示](https://img-blog.csdnimg.cn/87aac03c98e844c6847127339145d7c5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 文件快、磁盘块
![图示](https://img-blog.csdnimg.cn/4932b2cd9da348e98fdc3d2fb9d3e7fa.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/4d020900c9f142859758a724d9ca0dea.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 文件分配方式-连续分配
![图示](https://img-blog.csdnimg.cn/d5eb0727c94944c1b3dba882edd1ef4d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 优点： 
（1）**连续分配支持顺序访问和直接访问（随机访问）**。
（2）**连续分配的文件在顺序读/写时速度最快**。
* 缺点 
（1）物理上采取**连续分配的文件不方便拓展**。
（2）物理上采取**连续分配，存储空间的利用率低，会产生难以利用的磁盘碎片**。（可以用**紧凑**来处理碎片，但是需要耗费很大的时间代价）
#### 文件分配方式-链式分配
* **链式分配**采取离散分配的方式，可以为文件分配离散的磁盘块。分为**隐式链接**和**显式链接**。
#### 链接分配-隐式链接
![图示](https://img-blog.csdnimg.cn/f0ece0b46386450eab20a4d2656e77e0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 优点：很方便文件拓展，不会有碎片问题（所有的空闲磁盘块都可以被利用），外存利用率高。
* 缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的内存空间。
#### 链接分配-显式链接
显示链接：把用于链接文件各物理块的指针显式地存放在一张表中。即**文件分配表（FAT）**。
![图示](https://img-blog.csdnimg.cn/0c78ee58d8744685be70993f601b84d4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/05c70d3384154f95877693d1493de64c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 优点：很方便文件拓展，不会有碎片问题（所有的空闲磁盘块都可以被利用），外存利用率高，并且支持随机访问。相比于隐式链接来说，**地址转换时不需要访问磁盘**，因此文件的访问效率很高。
* 缺点：文件分配表需要占用一定的存储空间。
#### 文件分配方式-索引分配
![图示](https://img-blog.csdnimg.cn/10bdc913cb904923a000ba9c62f98aec.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 如果每个磁盘块 1KB，一个索引表项目 4B，则一个磁盘块只能存放 256 个索引项。如果一个文件的大小超过了 256 块，那么一个磁盘块是装不下文件的整张索引表的，如何解决这个问题？
（1）链接方案
（2）多层索引
（3）混合索引
#### 链接方案
* **链接方案**：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。
![图示](https://img-blog.csdnimg.cn/dd83560507f4410e9f9d6b81672175f5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 缺点：如果文件很大，索引表很长，就需要将多个索引块链接起来。想要找到 i 号索引块，必须先一次读入 0 到 i-1 号索引块，这就导致磁盘 I/O 次数过多，查找效率低下。
#### 多层索引
* **多层索引**：建立多层索引（**原理类似于多级页表**）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。
![图示](https://img-blog.csdnimg.cn/7eb82fb500964a96a4b2e68738440e60.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 采用 K 层索引结构，且**顶级索引表未调入内存**，则访问一个数据块只需要 K+1 次读磁盘操作。
* 缺点：即使是小文件，访问一个数据块依然需要 K+1 次读磁盘。
#### 混合索引
* **混合索引**：多种索引分配方式的结合。例如：一个文件的顶级索引表中，既包含**直接地址索引**（直接指向**数据块**），又包含**一级间接索引**（指向单层索引表），还包含**二级间接索引**（指向两层索引表）
![图示](https://img-blog.csdnimg.cn/cd4cb8c638a2469fbd55f46568b7b146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 小结
![图示](https://img-blog.csdnimg.cn/ee49f0dac9ba4ad981bacfbb57a63151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 4.5 文件存储空间管理
![图示](https://img-blog.csdnimg.cn/2912c702538b477fb52d7259f0284929.png)
#### 存储空间的划分与初始化
![图示](https://img-blog.csdnimg.cn/7c1b8eb6c2ca48d094b9343b9aaa317b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 存储空间管理-空闲表法
* 空闲表法适用于连续分配方式

![图示](https://img-blog.csdnimg.cn/ad746dafdf0c4087a7e93f7c0bed110f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 存储空间管理-空闲链表法
![图示](https://img-blog.csdnimg.cn/55fc38de62914e79bb2627046eb39425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/562f373d84124d52bcce7a61476ccc63.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 存储空间管理-位示图法
* 位示图法：连续分配、离散分配都适用。
![图示](https://img-blog.csdnimg.cn/c1ba9a2e16dc499cb98efb61045d51a1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/bd701d5b939d40d0b7a685433bdf358c.png)
#### 存储空间管理-成组链接法
![图示](https://img-blog.csdnimg.cn/2316de1c401c4c1aaed3c2178042c437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/024821b38afb4250a90ac4ab6c3e5925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 4.6 文件的基本操作
#### 创建文件
![图示](https://img-blog.csdnimg.cn/0c190340e2ab4cc0a7a7ffacb496c77c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 删除文件
![图示](https://img-blog.csdnimg.cn/cffe18a58b0e46fdb46bada9e6a68c4e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 打开文件
* 打开文件时并不会把文件数据直接读入内存。“索引号”也称“文件描述符”。
![图示](https://img-blog.csdnimg.cn/f416d246575c434f84b9e69b071a2205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/a312519b312c49ed9a7b7e5ac2f662ac.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 关闭文件
![图示](https://img-blog.csdnimg.cn/60d4ba6d75be4095857facf2373602ae.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)

#### 读文件
![图示](https://img-blog.csdnimg.cn/a2050f37f46f46498eeabec9ce42703a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 读文件用文件描述符即可指明文件，不再需要用到文件名。
#### 写文件
![图示](https://img-blog.csdnimg.cn/fd1f091907654830b20c138983be3276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 写文件用文件描述符即可指明文件，不再需要用到文件名。
### 4.7 文件共享
![图示](https://img-blog.csdnimg.cn/ddd89e9b09b745e8b5c002f959d242bd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 基于索引结点的共享方式（硬链接）
![图示](https://img-blog.csdnimg.cn/129ba453044b4de3b2e01b93e904f440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 基于符号链的共享方式（软链接）
![图示](https://img-blog.csdnimg.cn/3a17d4cb16d84188be3b3ec483d24347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/6d193991583c4c67bbc962f173276639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 4.8 文件保护
* 文件保护：保护文件数据的安全。
* 三种方式：
（1）口令保护。
（2）加密保护。
（3）访问控制。
#### 口令保护
![图示](https://img-blog.csdnimg.cn/3f7e7f26e93a4f5cb18499dac1a143b3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 加密保护
* 使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密。（也就是系统中保存的并不是文件的原始数据，而是保存了对文件进行加密后的数据，所以用户必须提供正确的密码进行解密才能正确读取文件）
* 优先：保密性强，不需要在系统中存储“密码”。
* 缺点：编码/译码，或者说加密/解密需要花费一定时间。
#### 访问控制
![图示](https://img-blog.csdnimg.cn/4e14d56bf1a44629878a8f4c4ceaea23.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 优点：实现灵活，可以实现复杂的文件保护功能。
* 注：如果对某个目录进行了访问权限的控制，那也要对目录下的所有文件进行相同的访问权限控制。
### 4.9 文件系统的层次结构
![图示](https://img-blog.csdnimg.cn/2c736f9ef6704f5f9b9b9355c9967366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/2d268cf1c789499a823ecef3fe492bf5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 4.10 磁盘的结构
#### 磁盘、磁道、扇区
![图示](https://img-blog.csdnimg.cn/ff8954459de94015ad31a4040d20b94e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 如何在磁盘中读/写数据
![图示](https://img-blog.csdnimg.cn/1bb959df2bdb425ca303b31833ae6383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 盘面、柱面
![图示](https://img-blog.csdnimg.cn/44ec3bbd4b1c4b629f042c13bde65e4d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 磁盘的物理地址
![图示](https://img-blog.csdnimg.cn/cea5a06bb8874b9797681c7bf873ac3d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 磁盘的分类
* 根据磁头是否可以移动
![图示](https://img-blog.csdnimg.cn/a5c6fd5035504cfbb5dc9b2b43cf0a46.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 根据盘片是否可以更换
（1）盘片可以更换的称为**可换盘磁盘**。
（2）盘片不可以更换的称为**固定盘磁盘**。
### 4.11 磁盘调度算法
#### 一次磁盘读/写操作需要的时间
![图示](https://img-blog.csdnimg.cn/6f87a218749549bb95746ca626dada7a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 先来先服务算法（FCFS）
* 根据进程请求访问磁盘的先后顺序进行调度。
* 优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过得去。
* 缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则 FCFS 在性能上很差，寻道时间长。
#### 最短寻找时间优先（SSTF）
* SSTF 算法优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。（其实就是贪心算法的思想，只选择眼前最优，但是总体未必最优）
* 优点：性能较好，平均寻道时间短。
* 缺点：**可能产生饥饿**现象。
#### 扫描算法（SCAN）
![图示](https://img-blog.csdnimg.cn/7422e78975ad41bcae5854c7ecb56505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### LOOK 调度算法（SCAN 算法的改进）
![图示](https://img-blog.csdnimg.cn/da9bc080d1ec40ff90e8617d2c8d8136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 循环扫描算法（C-SCAN）
![图示](https://img-blog.csdnimg.cn/fa8d49d0ae174674ba8f4d273673c5ff.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### C-LOOK 调度算法（C-SCAN 算法的改进）
![图示](https://img-blog.csdnimg.cn/7f4a5b3b209745849ec205059258dd32.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 4.12 减少磁盘延迟时间的方法
* **磁头读入一个扇区数据后需要一小段时间处理**，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的“延迟时间”。
#### 减少延迟时间的办法-交替编号
* 原理：读取完一个扇区后需要一段时间处理才可以继续读入下一个扇区。
![图示](https://img-blog.csdnimg.cn/b6db9324154f4f8aa93c7df08c731fb2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 减少延迟时间的办法-错位命名
* 具体做法：让相邻盘面的扇区编号“错位”。
* 原理：读取完一个扇区后需要一段时间处理才可以继续读入下一个扇区。
* 错位命名法**可以降低延迟时间**。
#### 磁盘地质结构的设计
* 为什么磁盘的物理地址是（柱面号，盘面号，扇区号），而不是（盘面号，柱面号，扇区号）？
读取地址连续的磁盘块时，采用（柱面号，盘面号，扇区号）的地址结构可以**减少磁头移动消耗的时间**。也就是说，前者在读取地址连续的磁盘块时，不需要移动磁头。
### 4.13 磁盘的管理
#### 磁盘初始化
![图示](https://img-blog.csdnimg.cn/ef7260ac55cb42c99bc19cf60c4fbf42.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 引导块
![图示](https://img-blog.csdnimg.cn/bb2f081baf8e43a2976a106a88a69619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 坏块的管理
![图示](https://img-blog.csdnimg.cn/768e113f520f48a0b7e5ba1dedcb2ea3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
## 五、I/O 管理
### 5.1 I/O 设备的概念和分类
#### I/O 设备的概念
* I/O 就是 输入/输出（Input/Output）
* I/O 设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。
* UNIX 系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作（Write 操作：向外部设备写出数据；Read 操作：从外部设备读入数据）
#### I/O 设备的分类
![图示](https://img-blog.csdnimg.cn/ba1b6a05616a410ea71c857ec0f62778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 5.2 I/O 控制器
* **I/O 设备由机械部件和电子部件（I/O控制器，也叫设备控制器）组成。**
#### I/O 设备的机械部件
* I/O 设备的**机械部件**主要用来执行具体的 I/O 操作。
* 例如：鼠标/键盘的按钮；显示器的 LED 屏。
* I/O 设备的**电子部件**通常是一块插入主板扩充槽的印刷电路板。
#### I/O 设备的电子部件（I/O 控制器）
![图示](https://img-blog.csdnimg.cn/31597b174e4a4ab5ba6cdd131f6c6a05.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### I/O 控制器的组成
![图示](https://img-blog.csdnimg.cn/bf8a8142f5c449ed91b5ef22d0ec5a5d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 内存映射 I/O 和 寄存器独立编址
![图示](https://img-blog.csdnimg.cn/ac74362337504e5d806bf24ac06d53b0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 5.3 I/O 控制方式
#### 程序直接控制方式
* 完成一次读/写操作的流程（以**读操作**为例）
![图示](https://img-blog.csdnimg.cn/af7ebab49a534c6c8b4a89727abb9fd3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/d9218119b40347019ae8f73dd3610e0b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 中断驱动方式
![图示](https://img-blog.csdnimg.cn/1e3923908578498f9f49fdbcd49e8c4a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/cacb04459a48436e9596e30fe5bd9745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### DMA 方式
![图示](https://img-blog.csdnimg.cn/1f3c720c12f44c6c87d8a55070f19b61.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/62c0554d894f437cab1ba2d6ac590cba.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### DMA 控制器
![图示](https://img-blog.csdnimg.cn/afbd16bb3b2341509e08d9129313120f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 通道控制方式
![图示](https://img-blog.csdnimg.cn/64a5572419cf41dca5205e7528f9f8a8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/73f56ad9d02f4abdaab7679887ec4046.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 小结
![图示](https://img-blog.csdnimg.cn/1ce49388287e45f9bfa66c54bee782ab.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 5.4 I/O 软件层次结构
#### 总体结构
![图示](https://img-blog.csdnimg.cn/b6fbcab4b01140429984e45ad40be20e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 用户层软件
![图示](https://img-blog.csdnimg.cn/7f057bc4a1824c3a9632e49b8e830c41.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 设备独立性软件
* **设备独立性软件**，又称**设备无关性软件**。与设备的硬件特性无关的功能几乎都在这一层实现。
* 主要实现的功能：
（1）向上层提供统一的调用接口（如 read/write 系统调用）；
（2）设备的保护。原理类似文件保护，设备被看成一种特殊的文件，不同用户对各个文件的访问权限不一样，同理，对设备的访问权限也不一样。
（3）差错处理。设备独立性软件需要对一些设备的错误进行处理。
（4）设备的分配与回收。
（5）数据缓冲区管理。
（6）建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序。**设备独立性软件**需要通过“**逻辑设备表（LUT）**”来确定逻辑设备对应的**物理设备**，并找到该设备对应的**设备驱动程序**。
![图示](https://img-blog.csdnimg.cn/3f97802ed89e4ddba24a87fadecd80e5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 为何不同的设备需要不同的设备驱动程序？
不同设备的内部硬件特性不同，这些特性只有厂家才知道，因此厂家必须提供与设备相对应的驱动程序，CPU 执行驱动程序的指令序列，来完成设置设备寄存器、检查设备状态等工作。
#### 设备驱动程序
* 设备驱动程序主要负责对硬件设备的具体控制，将上层发出的一系列命令（如 read/write）转化成特定设备“能听得懂”的一系列操作。包括设置设备寄存器、检查设备状态等。
* 不同的 I/O 设备有不同的硬件特性，具体细节只有厂家才知道。因此厂家需要根据设备的硬件特性设计并提供相应的驱动程序。
* 注：驱动程序一般会以一个独立进程的方式存在。
#### 中断处理程序
![图示](https://img-blog.csdnimg.cn/b270a3b0ebe34127bd94a675a4d4a80e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 小结
![图示](https://img-blog.csdnimg.cn/39b68eb7630a4e028100821c0680310e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 5.5 I/O 核心子系统
设备独立性软件、设备驱动程序、中断处理程序属于操作系统的内核部分，即“**I/O 系统**”，或称“**I/O 核心子系统**”
#### 常用功能要在哪个层次实现
![图示](https://img-blog.csdnimg.cn/27c4741c562f4c0f9ab024fc8397f0b9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### I/O 调度
* **I/O 调度：用某种算法确定一个好的顺序来处理各个 I/O 请求。**
* 如：磁盘调度（先来先服务算法、最短寻道优先算法、SCAN 算法、C-SCAN 算法、LOOK 算法、C-LOOK 算法）。当多个磁盘 I/O 请求到来时，用某种调度算法确定满足 I/O 请求的顺序。
* 同理，打印机等设备也可以用先来先服务算法、优先级算法、短作业优先等算法来确定 I/O 调度顺序。
#### 设备保护
* 操作系统需要实现**文件保护功能**，不同的用户对各个文件有不同的访问权限（如：只读、读和写等）
* 在 UNIX 系统中，**设备被看做是一种特殊的文件**，每个设备也会有对应的 FCB。当用户请求访问某个设备时，系统根据 FCB 中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能。

### 5.6 假脱机技术
#### 什么是脱机技术
![图示](https://img-blog.csdnimg.cn/60a35138da454f77bdd5fac170eb27b2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 假脱机技术
* **假脱机技术**，又称 **SPOOLing 技术**，是用软件的方式模拟脱机技术。
* SPOOLing 系统的组成如下：
（1）输入井和输出井
![图示](https://img-blog.csdnimg.cn/a51bec3f1cea4ae09cc84ceea875a44c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
（2）输入进程和输出进程
![图示](https://img-blog.csdnimg.cn/2886fecc42b4481687ccd58f0b8fdad4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
（3）输入/输出缓冲区
![图示](https://img-blog.csdnimg.cn/756e4a6bb6fa47cb9e1b31a72fb11143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 共享打印机原理分析
![图示](https://img-blog.csdnimg.cn/ca407faa2c18473393ca27911d551773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/6893a0157c314d4f8974a1a1223990f8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 5.7 设备的分配与回收
#### 设备分配时应考虑的因素
![图示](https://img-blog.csdnimg.cn/98c28a45efdd4838ab8a40e3b2c2c2aa.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 静态分配和动态分配
* 静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源。破坏了“请求和保持”条件，不会发生死锁。
* 动态分配：进程运行过程中动态申请设备资源。
#### 设备、管理器、通道之间的关系
![图示](https://img-blog.csdnimg.cn/8af84981ee2144d49a0edef1a8e06ab5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 设备分配管理中的数据结构
![图示](https://img-blog.csdnimg.cn/27a95bbdf0a14a3481b80e827b383fc8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/071b9f2417724baeb2b898db4494d3da.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/b14f16c7ad164e5388abfec3d8bff717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/c6ec15490e0a4332be0af2434f3c2fe2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 设备分配的步骤
![图示](https://img-blog.csdnimg.cn/d09a0c8d43cf4776bcf22e4df2c6d1fe.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 设备分配步骤的改进
* 上述设备分配步骤的缺点：
（1）用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程。
（2）若换了一个物理设备，则程序无法运行。
（3）若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待。
* 改进方法：建立逻辑设备名与物理设备名的映射机制，用户编程时只需要提供逻辑设备名。
![图示](https://img-blog.csdnimg.cn/f468758d3815487f8e42a61e87c297bc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
![图示](https://img-blog.csdnimg.cn/570e70bc888348f6a1d3941c5596c912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
### 5.8 缓冲区管理
#### 什么是缓冲区
* 缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可以利用内存作为缓冲区。
* 利用**硬件作为缓冲区**的**成本较高，容量也较少**，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）
* 一般情况下，更多的是利用**内存作为缓冲区**，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区。
#### 缓冲区有什么作用
![图示](https://img-blog.csdnimg.cn/28e0842391e349c5901ef0ff64b1699d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 单缓冲
![图示](https://img-blog.csdnimg.cn/d1d7deba87e4468a9bf15621f1161b67.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* 常考题型：计算每处理一块数据平均需要多久。
技巧：假定一个初始状态，分析下次到达相同状态需要多长时间，这就是处理一块数据平均所需时间。在单缓冲题型中，可以假设初始状态为工作区满、缓冲区空。
* **结论：采用单缓冲策略，处理一块数据平均耗时为 Max(C, T) + M。**
#### 双缓冲
* 假设某用户进程请求某种设备读入若干块的数据。若采用**双缓冲**的策略，操作系统**会在主存中为其分配两个缓冲区**（若题目中没有特别说明，一个缓冲区的大小就是一个块）
* 双缓冲题目中，假设初始状态为：工作区空，其中一个缓冲区满，另一个缓冲区空。
* **结论：采用双缓冲策略，处理一个数据块的平均耗时为 Max(T, C+M)。**
#### 使用单/双缓冲区在通信时的区别
![图示](https://img-blog.csdnimg.cn/ff01442feb944476a7bee2a6f7004d6e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 循环缓冲区
![图示](https://img-blog.csdnimg.cn/1a89aca241c8460d8d961191b5c00617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
#### 缓冲池
![图示](https://img-blog.csdnimg.cn/c621c20e2b2b4f709261428b58cc731d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
* （1）输入进程请求输入数据：从空缓冲队列中取出一块作为“收容输入数据的工作缓冲区（hin）”。冲满数据后将缓冲区挂到输入队列队尾。
* （2）计算进程想要取得一块输入数据：从输入队列中取得一块冲满输入数据的缓冲区作为“提取输入数据的工作缓冲区（sin）”。缓冲区读空后挂到空缓冲区队列。
* （3）计算进程想要将准备好的数据冲入缓冲区：从空缓冲队列中取出一块作为“收容输出数据的工作缓冲区（hout）”。数据冲满后将缓冲区挂到输出队列队尾。
* （4）输出进程请求输出数据：从输出队列中取得一块冲满输出数据的缓冲区作为“提取输出数据的工作缓冲区（sout）”。缓冲区读空后挂到空缓冲区队列。





































































































