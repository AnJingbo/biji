

377. 组合总和 Ⅳ
给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。

示例:
nums = [1, 2, 3]
target = 4
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
因此输出为 7。

思路：
本题题目描述说是求组合，但又说是可以元素相同顺序不同的组合算两个组合，其实就是求排列！

弄清什么是组合，什么是排列很重要。

**组合不强调顺序，(1,5)和(5,1)是同一个组合。
排列强调顺序，(1,5)和(5,1)是两个不同的排列。**

动规五部曲：

**1、确定dp数组以及下标的含义**

dp[j]: **凑成目标正整数为 j 的排列个数为dp[j]**

**2、确定递推公式**

dp[j]（考虑nums[i]）可以由 dp[j - nums[i]]（不考虑nums[i]） 推导出来。

因为只要得到nums[i]，排列个数dp[j - nums[i]]，就是dp[j]的一部分。

**求装满背包有几种方法，递推公式一般都是dp[j] += dp[j - nums[i]];**

**3、dp数组如何初始化**
因为递推公式dp[j] += dp[j - nums[i]]的缘故，dp[0]要初始化为1，这样递归其他dp[i]的时候才会有数值基础。

至于dp[0] = 1 有没有意义呢？

其实没有意义，所以我也不去强行解释它的意义了，因为题目中也说了：给定目标值是正整数！所以dp[0] = 1是没有意义的，仅仅是为了推导递推公式。

至于非0下标的dp[i]应该初始为多少呢？

初始化为0，这样才不会影响dp[j]累加所有的dp[j - nums[i]]。

**4、确定遍历顺序**
个数可以不限使用，说明这是一个完全背包。

得到的集合是排列，说明需要考虑元素之间的顺序。

本题要求的是排列，那么这个for循环嵌套的顺序可以有说法了。

**如果求组合数就是外层for循环遍历物品，内层for遍历背包。
如果求排列数就是外层for遍历背包，内层for循环遍历物品。**

如果把遍历nums（物品）放在外循环，遍历target（背包容量）的作为内循环的话，举一个例子：计算dp[4]的时候，结果集只有 {1,3} 这样的集合，不会有{3,1}这样的集合，因为nums遍历放在外层，3只能出现在1后面！

所以本题遍历顺序最终遍历顺序：target（背包容量）放在外循环，将nums（物品）放在内循环，内循环从前到后遍历。

**5、举例来推导dp数组**
我们再来用示例中的例子推导一下：
![图示](https://img-blog.csdnimg.cn/20210201160308473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ5NzUwMw==,size_16,color_FFFFFF,t_70)
**求排列问题就用以下这种方法：一维dp先遍历背包再遍历物品**。不能用二维dp，因为二维dp无论for循环嵌套顺序，求出来的都是组合，求不出排列
```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target + 1];//装满容量为 j 的背包的方法个数是 dp[j]
        dp[0] = 1;

        for(int j = 1; j <= target; j++){//遍历背包容量
            for(int i = 0; i < nums.length; i++){//遍历物品
                if(j >= nums[i]){
                    dp[j] += dp[j - nums[i]];
                }
            }
        }
        return dp[target];
    }
}
```